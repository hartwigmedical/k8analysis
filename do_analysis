#!/usr/bin/env bash

THREAD_COUNT=$(($(grep -c processor /proc/cpuinfo) * 8 / 10 ))
SCRIPT_NAME=$(basename "$0")

GSUTIL="gsutil"
JAVA="java"
BWA="$HOME/bwa"
SAMBAMBA="$HOME/sambamba"
UMI_COLLAPSE_DIR="$HOME/UMICollapse"
UMI_COLLAPSE="${UMI_COLLAPSE_DIR}/umicollapse"

LOCAL_LANE_BAM_DIR="$HOME/lane_bams"
LOCAL_GCP_CACHE_DIR="$HOME/gcp_cache"

REF_GENOME_37_BUCKET_PATH="gs://common-resources/reference_genome/37/"
REF_GENOME_37_FASTA_FILE="Homo_sapiens.GRCh37.GATK.illumina.fasta"
REF_GENOME_38_BUCKET_PATH="gs://common-resources/reference_genome/38/"
REF_GENOME_38_FASTA_FILE="GCA_000001405.15_GRCh38_no_alt_analysis_set.fna"

SAMBAMBA_MARKDUP_OVERFLOW_LIST_SIZE=45000000

do_analysis() {
  info "Starting with ${SCRIPT_NAME}"

  # sanity checks
  tool_exists_or_die "${GSUTIL}"
  tool_exists_or_die "${JAVA}"
  file_exists_or_die "${BWA}"
  file_exists_or_die "${SAMBAMBA}"
  file_exists_or_die "${UMI_COLLAPSE}"

  info "Passed sanity checks"

  mkdir -p "${LOCAL_LANE_BAM_DIR}" || die "Could not create local lane bam dir"
  mkdir -p "${LOCAL_GCP_CACHE_DIR}" || die "Could not create local gcp cache dir"

  local remaining_args_string
  remaining_args_string=$(trim_excess_whitespace "${*}") || die "Could not get command line arguments as a string"

  local job_arg
  while [[ ${#remaining_args_string} -gt 0 ]]
  do
    job_arg=$(get_first_word "${remaining_args_string}") || die "Could not get job arg"
    remaining_args_string=$(delete_first_word "${remaining_args_string}") || die "Could not shift array"
    info "Detected job: ${job_arg}"
    case ${job_arg} in
      align)
        remaining_args_string="$(align "${remaining_args_string}")" || die "Could not complete ${job_arg} job";;
      no_umi_dedup)
        remaining_args_string="$(no_umi_dedup "${remaining_args_string}")" || die "Could not complete ${job_arg} job";;
      umi_dedup)
        remaining_args_string="$(umi_dedup "${remaining_args_string}")" || die "Could not complete ${job_arg} job";;
      flagstat)
        remaining_args_string="$(flagstat "${remaining_args_string}")" || die "Could not complete ${job_arg} job";;
      count_mapping_coords)
        remaining_args_string="$(count_mapping_coords "${remaining_args_string}")" || die "Could not complete ${job_arg} job";;
      *)
         die "Unrecognized job name: ${job_arg}";;
      esac
  done

  info "Finished with ${SCRIPT_NAME}"
}

align() {
  info "Start ${FUNCNAME[0]} job"

  info "Finished ${FUNCNAME[0]} job"
}

no_umi_dedup() {
  info "Start ${FUNCNAME[0]} job"

  info "Finished ${FUNCNAME[0]} job"
}

umi_dedup() {
  info "Start ${FUNCNAME[0]} job"

  info "Finished ${FUNCNAME[0]} job"
}

flagstat() {
  info "Start ${FUNCNAME[0]} job"

  info "Finished ${FUNCNAME[0]} job"
}

count_mapping_coords() {
  info "Start ${FUNCNAME[0]} job"

  info "Finished ${FUNCNAME[0]} job"
}

trim_excess_whitespace() {
  local input=$1 && shift
  [[ -n ${input} ]] || die "Not enough arguments to ${FUNCNAME[0]}"
  echo "${*}" | xargs echo -n
}

get_first_word() {
  local input=$1 && shift
  [[ -n ${input} ]] || die "Not enough arguments to ${FUNCNAME[0]}"
  echo "${input%% *}"
}

delete_first_word() {
  local input=$1 && shift
  [[ -n ${input} ]] || die "Not enough arguments to ${FUNCNAME[0]}"
  echo "${input# *}"
}

tool_exists_or_die() {
  local tool=$1 && shift
  [[ -n ${tool} ]] || die "Not enough arguments to ${FUNCNAME[0]}"
  command -v "${tool}" >/dev/null 2>&1 || die "Tool '${tool}' not found"
}

file_exists_or_die() {
  local file=$1 && shift
  [[ -n ${file} ]] || die "Not enough arguments to ${FUNCNAME[0]}"
  [[ -f "${file}" ]] || die "File '${file}' not found"
}

msg() {
  local msg_type=$1 && shift
  local msg_content=$* && shift
  echo "[${msg_type}] $(date +'%y%m%d %T') - ${msg_content}"
}

die() {
  error_msg "$@"
  exit 1
}

warn() {
  msg "WARN" "$@" >&2
}

info() {
  msg "INFO" "$@"
}

error_msg() {
  msg "ERROR" "$@" >&2
}

do_analysis "$@"