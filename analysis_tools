#!/usr/bin/env bash

SCRIPT_NAME=$(basename "$0") || exit 1

GSUTIL="gsutil"
JAVA="java"
BWA="$HOME/bwa"
SAMBAMBA="$HOME/sambamba"
UMI_COLLAPSE_DIR="$HOME/UMICollapse"
UMI_COLLAPSE="${UMI_COLLAPSE_DIR}/umicollapse"

LOCAL_LANE_BAM_DIR="$HOME/lane_bams"
LOCAL_GCP_CACHE_DIR="$HOME/gcp_cache"

REF_GENOME_37_BUCKET_PATH="gs://common-resources/reference_genome/37/"
REF_GENOME_37_FASTA_FILE="Homo_sapiens.GRCh37.GATK.illumina.fasta"
REF_GENOME_38_BUCKET_PATH="gs://common-resources/reference_genome/38/"
REF_GENOME_38_FASTA_FILE="GCA_000001405.15_GRCh38_no_alt_analysis_set.fna"

SAMBAMBA_MARKDUP_OVERFLOW_LIST_SIZE=45000000

REAL_EXECUTE_TRUE="REAL_EXECUTE_TRUE"
REAL_EXECUTE_FALSE="REAL_EXECUTE_FALSE"


print_non_umi_dedup_usage() {
  echo "Run sambamba markdup at GCP. "
  echo "USAGE: $0 run non_umi_dedup \ "
  echo "    --input <input-path> \ "
  echo "    --output <output-path> \ "
  echo "  [-i/--input]                              (Required)    Path to the bam file on which deduplication will be run,"
  echo "                                                          e.g. gs://some-kind/of/path.bam"
  echo "                                                          Make sure that an index file is also available,"
  echo "                                                          e.g. gs://some-kind/of/path.bam.bai"
  echo "  [-o/--output]                             (Required)    Path in bucket to which the deduplicated bam will be written,"
  echo "                                                          e.g. gs://some-other-kind/of/path.bam"
  echo "                                                          Will also output an index file,"
  echo "                                                          e.g. gs://some-other-kind/of/path.bam.bai"
  exit 1
}

print_umi_dedup_usage() {
  echo "Run UMI-Collapse dedupping at GCP. "
  echo "USAGE: $0 run umi_dedup \ "
  echo "    --input <input-path> \ "
  echo "    --output <output-path> \ "
  echo "  [-i/--input]                              (Required)    Path to the bam file on which deduplication will be run,"
  echo "                                                          e.g. gs://some-kind/of/path.bam"
  echo "                                                          Make sure that an index file is also available,"
  echo "                                                          e.g. gs://some-kind/of/path.bam.bai"
  echo "  [-o/--output]                             (Required)    Path in bucket to which the deduplicated bam will be written,"
  echo "                                                          e.g. gs://some-other-kind/of/path.bam"
  echo "                                                          Will also output an index file,"
  echo "                                                          e.g. gs://some-other-kind/of/path.bam.bai"
  exit 1
}

print_flagstat_usage() {
  echo "Run sambamba flagstat at GCP. "
  echo "USAGE: $0 run flagstat \ "
  echo "    --input <input-path> \ "
  echo "    --output <output-path> \ "
  echo "  [-i/--input]                              (Required)    Path to the bam file on which sambamba flagstat will be run,"
  echo "                                                          e.g. gs://some-kind/of/path.bam"
  echo "                                                          Make sure that an index file is also available,"
  echo "                                                          e.g. gs://some-kind/of/path.bam.bai"
  echo "  [-o/--output]                             (Required)    Path in bucket to which flagstat file will be written,"
  echo "                                                          e.g. gs://some-other-kind/of/path.flagstat"
  exit 1
}

do_analysis() {
  info "Starting with ${SCRIPT_NAME}"

  # sanity checks
  tool_exists_or_die "${GSUTIL}"
  tool_exists_or_die "${JAVA}"
  file_exists_or_die "${BWA}"
  file_exists_or_die "${SAMBAMBA}"
  file_exists_or_die "${UMI_COLLAPSE}"

  info "Passed sanity checks"

  mkdir -p "${LOCAL_LANE_BAM_DIR}" || die "Could not create local lane bam dir"
  mkdir -p "${LOCAL_GCP_CACHE_DIR}" || die "Could not create local gcp cache dir"

  local args_string
  args_string=$(trim_excess_whitespace "${*}") || die "Could not get command line arguments as a string"

  execute_jobs "${args_string}" "${REAL_EXECUTE_TRUE}"

  info "Finished with ${SCRIPT_NAME}"
}

execute_jobs(){
  info "Start ${FUNCNAME[0]}"
  local remaining_args_string=$1 && shift
  local real_execute=$1 && shift  # so not a dry run to check the parameter parsing
  [[ -n ${real_execute} ]] || die "Not enough arguments to ${FUNCNAME[0]}"

  # sanity checks
  [[ "${real_execute}" == "${REAL_EXECUTE_TRUE}" ]] || [[ "${real_execute}" == "${REAL_EXECUTE_FALSE}" ]] || \
        die "Did not recognize 'real_execute' argument. Should be ${REAL_EXECUTE_TRUE} or ${REAL_EXECUTE_FALSE}. Was: ${real_execute}"
  [[ ${#remaining_args_string} -gt 0 ]] || die "No jobs provided"
  info "Passed sanity checks"

  info "Arguments to parse: ${remaining_args_string}"
  info "Real execute status: ${real_execute}"

  local job_arg
  while [[ ${#remaining_args_string} -gt 0 ]]
  do
    job_arg=$(get_first_word "${remaining_args_string}") || die "Could not get job arg"
    remaining_args_string=$(delete_first_word "${remaining_args_string}") || die "Could not remove job arg"
    info "Detected job: ${job_arg}"
    case ${job_arg} in
      align)
        remaining_args_string="$(align "${remaining_args_string}" "${real_execute}")" || die "Could not complete ${job_arg} job";;
      non_umi_dedup)
        remaining_args_string="$(non_umi_dedup "${remaining_args_string}" "${real_execute}")" || die "Could not complete ${job_arg} job";;
      umi_dedup)
        remaining_args_string="$(umi_dedup "${remaining_args_string}" "${real_execute}")" || die "Could not complete ${job_arg} job";;
      flagstat)
        remaining_args_string="$(flagstat "${remaining_args_string}" "${real_execute}")" || die "Could not complete ${job_arg} job";;
      count_mapping_coords)
        remaining_args_string="$(count_mapping_coords "${remaining_args_string}" "${real_execute}")" || die "Could not complete ${job_arg} job";;
      *)
         die "Unrecognized job name: ${job_arg}";;
      esac
  done
  info "Finished ${FUNCNAME[0]}"
}

align() {
  info "Start ${FUNCNAME[0]} job"

  local remaining_args_string=$1 && shift
  local real_execute=$1 && shift  # so not a dry run to check the parameter parsing
  [[ -n ${real_execute} ]] || die "Not enough arguments to ${FUNCNAME[0]}"



  info "Finished ${FUNCNAME[0]} job"

  echo "${remaining_args_string}"
}

non_umi_dedup() {
  info "Start ${FUNCNAME[0]} job"

  local remaining_args_string=$1 && shift
  local real_execute=$1 && shift  # so not a dry run to check the parameter parsing
  [[ -n ${real_execute} ]] || die "Not enough arguments to ${FUNCNAME[0]}"

  local key
  local input
  local output
  while [[ ${#remaining_args_string} -gt 0 ]]
  do
    key=$(get_first_word "${remaining_args_string}") || die "Could not get job arg"
    case $key in
      -i|--input)  # required
        remaining_args_string=$(delete_first_word "${remaining_args_string}") || die "Could not remove key arg"
        input=$(get_first_word "${remaining_args_string}") || die "Could not get ${key} arg"
        remaining_args_string=$(delete_first_word "${remaining_args_string}") || die "Could not remove ${key} arg";;
      -o|--output)  # required
        remaining_args_string=$(delete_first_word "${remaining_args_string}") || die "Could not remove key arg"
        output=$(get_first_word "${remaining_args_string}") || die "Could not get ${key} arg"
        remaining_args_string=$(delete_first_word "${remaining_args_string}") || die "Could not remove ${key} arg";;
      -*)
        print_error_msg "Unrecognized option: ${key}"
        print_non_umi_dedup_usage && exit 1;;
      *)
        break;;
    esac
  done

  # sanity checks
  local input_error=false
  if [[ -z ${input} ]]; then
    print_error_msg "Variable 'input' has not been set"
    input_error=true
  fi
  if [[ -z ${output} ]]; then
    print_error_msg "Variable 'output' has not been set"
    input_error=true
  fi
  if [[ -n ${input} && ! "${input}" =~ ^gs://[*-/._a-zA-Z0-9]+.bam$ ]]; then
    print_error_msg "Variable 'input' needs to be set to a path to a bam file in a bucket, e.g. gs://some-kind/of/path.bam"
    input_error=true
  fi
  if [[ -n ${output} && ! "${output}" =~ ^gs://[-/._a-zA-Z0-9]+.bam ]]; then
    print_error_msg "Variable 'output' needs to be set to a path of the form 'gs://some-kind/of/path.bam'"
    input_error=true
  fi
  if [[ ${input_error} == true ]]; then
    echo ""
    print_non_umi_dedup_usage && exit 1
  fi

  info "Passed ${FUNCNAME[0]} sanity checks"
  info "Do non-umi dedup:\ninput=${input}\noutput=${output}"

  if [[ "${real_execute}" != "${REAL_EXECUTE_TRUE}" ]]; then
    info "Skip because of dry-run"
  elif [[ $(file_exists_in_bucket "${output}") ]]; then
    info "Skip because output file already exists in bucket"
  else
    local thread_count
    local local_input_path
    local local_output_path
    thread_count=$(get_thread_count) || die "Could not get thread count"
    local_input_path=$(fill_local_cache "${input}") || die "Could not get local version of ${input}"
    fill_local_cache "${input}.bai" || die "Could not get local version of ${input}.bai"
    local_output_path=$(get_local_cache_path "${output}") || die "Could not get local version of ${output}"

    info "Start sambamba markdup"
    "${SAMBAMBA}" markdup -t "${thread_count}" --overflow-list-size="${SAMBAMBA_MARKDUP_OVERFLOW_LIST_SIZE}" \
        "${local_input_path}" "${local_output_path}" \
        || die "Could not run sambamba markdup"
    info "Finished sambamba markdup"

    info "Start sambamba index"
    "${SAMBAMBA}" index -t "${thread_count}" "${local_output_path}" || die "Could not index bam ${local_output_path}"
    info "Finished sambamba index"

    upload_from_local_cache "${output}" || die "Failed to upload output to ${output}"
    upload_from_local_cache "${output}.bai" || die "Failed to upload output.bai to ${output}.bai"
  fi

  info "Finished ${FUNCNAME[0]} job"

  echo "${remaining_args_string}"
}

umi_dedup() {
  info "Start ${FUNCNAME[0]} job"

  local remaining_args_string=$1 && shift
  local real_execute=$1 && shift  # so not a dry run to check the parameter parsing
  [[ -n ${real_execute} ]] || die "Not enough arguments to ${FUNCNAME[0]}"

  local key
  local input
  local output
  while [[ ${#remaining_args_string} -gt 0 ]]
  do
    key=$(get_first_word "${remaining_args_string}") || die "Could not get job arg"
    case $key in
      -i|--input)  # required
        remaining_args_string=$(delete_first_word "${remaining_args_string}") || die "Could not remove key arg"
        input=$(get_first_word "${remaining_args_string}") || die "Could not get ${key} arg"
        remaining_args_string=$(delete_first_word "${remaining_args_string}") || die "Could not remove ${key} arg";;
      -o|--output)  # required
        remaining_args_string=$(delete_first_word "${remaining_args_string}") || die "Could not remove key arg"
        output=$(get_first_word "${remaining_args_string}") || die "Could not get ${key} arg"
        remaining_args_string=$(delete_first_word "${remaining_args_string}") || die "Could not remove ${key} arg";;
      -*)
        print_error_msg "Unrecognized option: ${key}"
        print_umi_dedup_usage && exit 1;;
      *)
        break;;
    esac
  done

  # sanity checks
  local input_error=false
  if [[ -z ${input} ]]; then
    print_error_msg "Variable 'input' has not been set"
    input_error=true
  fi
  if [[ -z ${output} ]]; then
    print_error_msg "Variable 'output' has not been set"
    input_error=true
  fi
  if [[ -n ${input} && ! "${input}" =~ ^gs://[*-/._a-zA-Z0-9]+.bam$ ]]; then
    print_error_msg "Variable 'input' needs to be set to a path to a bam file in a bucket, e.g. gs://some-kind/of/path.bam"
    input_error=true
  fi
  if [[ -n ${output} && ! "${output}" =~ ^gs://[-/._a-zA-Z0-9]+.bam ]]; then
    print_error_msg "Variable 'output' needs to be set to a path of the form 'gs://some-kind/of/path.bam'"
    input_error=true
  fi
  if [[ ${input_error} == true ]]; then
    echo ""
    print_umi_dedup_usage && exit 1
  fi

  info "Passed ${FUNCNAME[0]} sanity checks"
  info "Do umi dedup:\ninput=${input}\noutput=${output}"

  if [[ "${real_execute}" != "${REAL_EXECUTE_TRUE}" ]]; then
    info "Skip because of dry-run"
  elif [[ $(file_exists_in_bucket "${output}") ]]; then
    info "Skip because output file already exists in bucket"
  else
    local thread_count
    local local_input_path
    local local_output_path
    thread_count=$(get_thread_count) || die "Could not get thread count"
    local_input_path=$(fill_local_cache "${input}") || die "Could not get local version of ${input}"
    fill_local_cache "${input}.bai" || die "Could not get local version of ${input}.bai"
    local_output_path=$(get_local_cache_path "${output}") || die "Could not get local version of ${output}"

    info "Start UMI-Collapse"
    pushd "${UMI_COLLAPSE_DIR}" || die "Could not cd into UMI-Collapse dir"
    "${UMI_COLLAPSE}" bam -i "${local_input_path}" -o "${local_output_path}" --umi-sep ":" --paired --two-pass \
        || die "Could not run UMI-Collapse"
    popd || die "Could not cd out of UMI-Collapse dir"
    info "Finished UMI-Collapse"

    info "Start sambamba index"
    "${SAMBAMBA}" index -t "${thread_count}" "${local_output_path}" || die "Could not index bam ${local_output_path}"
    info "Finished sambamba index"

    upload_from_local_cache "${output}" || die "Failed to upload output to ${output}"
    upload_from_local_cache "${output}.bai" || die "Failed to upload output.bai to ${output}.bai"
  fi

  info "Finished ${FUNCNAME[0]} job"

  echo "${remaining_args_string}"
}

flagstat() {
  info "Start ${FUNCNAME[0]} job"

  local remaining_args_string=$1 && shift
  local real_execute=$1 && shift  # so not a dry run to check the parameter parsing
  [[ -n ${real_execute} ]] || die "Not enough arguments to ${FUNCNAME[0]}"

  local key
  local input
  local output
  while [[ ${#remaining_args_string} -gt 0 ]]
  do
    key=$(get_first_word "${remaining_args_string}") || die "Could not get job arg"
    case $key in
      -i|--input)  # required
        remaining_args_string=$(delete_first_word "${remaining_args_string}") || die "Could not remove key arg"
        input=$(get_first_word "${remaining_args_string}") || die "Could not get ${key} arg"
        remaining_args_string=$(delete_first_word "${remaining_args_string}") || die "Could not remove ${key} arg";;
      -o|--output)  # required
        remaining_args_string=$(delete_first_word "${remaining_args_string}") || die "Could not remove key arg"
        output=$(get_first_word "${remaining_args_string}") || die "Could not get ${key} arg"
        remaining_args_string=$(delete_first_word "${remaining_args_string}") || die "Could not remove ${key} arg";;
      -*)
        print_error_msg "Unrecognized option: ${key}"
        print_flagstat_usage && exit 1;;
      *)
        break;;
    esac
  done

  # sanity checks
  local input_error=false
  if [[ -z ${input} ]]; then
    print_error_msg "Variable 'input' has not been set"
    input_error=true
  fi
  if [[ -z ${output} ]]; then
    print_error_msg "Variable 'output' has not been set"
    input_error=true
  fi
  if [[ -n ${input} && ! "${input}" =~ ^gs://[*-/._a-zA-Z0-9]+.bam$ ]]; then
    print_error_msg "Variable 'input' needs to be set to a path to a bam file in a bucket, e.g. gs://some-kind/of/path.bam"
    input_error=true
  fi
  if [[ -n ${output} && ! "${output}" =~ ^gs://[-/._a-zA-Z0-9]+.flagstat ]]; then
    print_error_msg "Variable 'output' needs to be set to a path of the form 'gs://some-kind/of/path.flagstat'"
    input_error=true
  fi
  if [[ ${input_error} == true ]]; then
    echo ""
    print_flagstat_usage && exit 1
  fi

  info "Passed ${FUNCNAME[0]} sanity checks"
  info "Determine flagstat:\ninput=${input}\noutput=${output}"

  if [[ "${real_execute}" != "${REAL_EXECUTE_TRUE}" ]]; then
    info "Skip because of dry-run"
  elif [[ $(file_exists_in_bucket "${output}") ]]; then
    info "Skip because output file already exists in bucket"
  else
    local thread_count
    local local_bam_path
    local local_flagstat_path
    thread_count=$(get_thread_count) || die "Could not get thread count"
    local_bam_path=$(fill_local_cache "${input}") || die "Could not get local version of ${input}"
    fill_local_cache "${input}.bai" || die "Could not get local version of ${input}.bai"
    local_flagstat_path=$(get_local_cache_path "${output}") || die "Could not get local version of ${output}"

    info "Start sambamba flagstat"
    "${SAMBAMBA}" flagstat -t "${thread_count}" "${local_bam_path}" > "${local_flagstat_path}" || die "Could not run flagstat"
    info "Finished sambamba flagstat"

    upload_from_local_cache "${output}" || die "Failed to upload output to ${output}"
  fi

  info "Finished ${FUNCNAME[0]} job"

  echo "${remaining_args_string}"
}

fill_local_cache() {
  local bucket_path=$1 && shift
  [[ -n ${bucket_path} ]] || die "Not enough arguments to ${FUNCNAME[0]}"
  local local_path
  local_path=$(get_local_cache_path "${bucket_path}") || die "Could not get local path for ${bucket_path}"

  if [[ ! -f ${local_path} ]]; then
    info "Download ${bucket_path}"
    "${GSUTIL}" -m cp "${bucket_path}" "${local_path}"
  fi
  [[ -f ${local_path} ]] || die "Download of ${bucket_path} failed"
  echo "${local_path}"
}

upload_from_local_cache() {
  local bucket_path=$1 && shift
  [[ -n ${bucket_path} ]] || die "Not enough arguments to ${FUNCNAME[0]}"
  local local_path
  local_path=$(get_local_cache_path "${bucket_path}") || die "Could not get local path for ${bucket_path}"

  "${GSUTIL}" -m cp "${local_path}" "${bucket_path}"
  [[ $(file_exists_in_bucket "${bucket_path}") ]] || die "Upload to ${bucket_path} failed"
}

get_local_cache_path() {
  local bucket_path=$1 && shift
  [[ -n ${bucket_path} ]] || die "Not enough arguments to ${FUNCNAME[0]}"
  echo "${bucket_path/"gs://"/"${LOCAL_GCP_CACHE_DIR}/"}"
}

count_mapping_coords() {
  info "Start ${FUNCNAME[0]} job"

  local remaining_args_string=$1 && shift
  local real_execute=$1 && shift  # so not a dry run to check the parameter parsing
  [[ -n ${real_execute} ]] || die "Not enough arguments to ${FUNCNAME[0]}"

  info "Finished ${FUNCNAME[0]} job"

  echo "${remaining_args_string}"
}

file_exists_in_bucket() {
  local bucket_path=$1 && shift
  [[ -n ${bucket_path} ]] || die "Not enough arguments to ${FUNCNAME[0]}"
  if [[ $(${GSUTIL} -q stat "${bucket_path}") ]]; then
    return 0
  else
    return 1
  fi
}

get_thread_count(){
  echo $(($(grep -c processor /proc/cpuinfo) * 8 / 10 ))
}

trim_excess_whitespace() {
  local input=$1 && shift
  [[ -n ${input} ]] || die "Not enough arguments to ${FUNCNAME[0]}"
  echo "${input}" | xargs echo -n
}

get_first_word() {
  local input=$1 && shift
  [[ -n ${input} ]] || die "Not enough arguments to ${FUNCNAME[0]}"
  echo "${input%% *}"
}

delete_first_word() {
  local input=$1 && shift
  [[ -n ${input} ]] || die "Not enough arguments to ${FUNCNAME[0]}"
  echo "${input# *}"
}

tool_exists_or_die() {
  local tool=$1 && shift
  [[ -n ${tool} ]] || die "Not enough arguments to ${FUNCNAME[0]}"
  command -v "${tool}" >/dev/null 2>&1 || die "Tool '${tool}' not found"
}

file_exists_or_die() {
  local file=$1 && shift
  [[ -n ${file} ]] || die "Not enough arguments to ${FUNCNAME[0]}"
  [[ -f "${file}" ]] || die "File '${file}' not found"
}

msg() {
  local msg_type=$1 && shift
  local msg_content=$* && shift
  echo "[${msg_type}] $(date +'%y%m%d %T') - ${msg_content}"
}

die() {
  print_error_msg "$@"
  exit 1
}

warn() {
  msg "WARN" "$@" >&2
}

info() {
  msg "INFO" "$@"
}

print_error_msg() {
  msg "ERROR" "$@" >&2
}